module Grinlens

export Parameters, Observables, propagate

include("./gaussianbeam.jl")
using .GaussianBeam

# discrete model for continuous grin lens

# parameters
Base.@kwdef struct Parameters
    # medium parameters
    n       # index of refraction
    λ       # wavelength (m)
    P       # power of laser (W)
    k       # water thermic diffusion coefficient (W/m/K)
    α       # water absorption coefficient (1/m)
    dndT    # index variation coefficient (1/K)
    focale::Function  # thermally induced focal length of liquid slice

    # input beam parameters    
    z0      # initial position of the waist without lens effect (m)
    w0      # initial waist of the beam (m)
    
    # iteration parameters
    l       # width of the liquid slices (m)
    steps   # position along the tank to compute on
end

# default parameters
function Parameters(;
    n = 1.33,
    λ = 915e-9,
    P = 0.5,
    k = 0.6,
    α = 8,
    dndT = -1e-4,
    focale = Nothing,
    z0 = 1e-2,
    w0 = 6.5e-6,
    l = 1e-5,
    steps = 0:l:3e-2,
)
    if focale == Nothing # define default model depending on medium parameters
        focale = (l,w) ->  π * k * w^2 / ( α * P * l * dndT)
    end
    return Parameters(n,λ,P,k,α,dndT,focale,z0,w0,l,steps)
end
   
# observables
mutable struct Observables
    focal::Vector   # focal length of liquid slice lens 
    shift::Vector   # focal shift generated by liquid slice lens
    magnif::Vector  # magnification for liquid slice lens 
    pos::Vector     # position of the waist after liquid slice lens 
    waist::Vector   # size of the waist after liqud slice lens 
    wonlens::Vector # beam width on the lens 
    dist::Vector    # distance from lens to object waist
    minwidth        # minimal width of the beam
    minwidthpos     # first position of minimal width
end

Observables(n::Int) = Observables(zeros(n),zeros(n),zeros(n),zeros(n),zeros(n),zeros(n),zeros(n),Nothing,Nothing) # init arrays


# simulate a gaussian beam propagation in water
function propagate(n,λ,focale,z0,w0,l,steps)
    # observables
    o = Observables(length(steps))   # length of vector

    # loop for each element lens
    for (i,z) in enumerate(steps)        
        # compute lens effect
        sa = z0 - z                         # algebric distance lens-object
        w0a = w0                            # waist before lens
        zra = rayleigh_length(n, w0a, λ)       # Rayleigh length before lens
        wa = gaussian_width(n, sa, w0a, λ)     # beam width at lens position
        fprime = focale(l, wa)              # thermally induced focal length
        sb = sprime(sa, fprime, zra)        # algebric distance lens-image
        mag = magnification(sa, fprime, zra)
        w0b = w0a * mag                     # waist after lens

        # update beam properties
        z0 = z + sb                         # update z0 with new absolute beam position
        w0 = w0b                            # update w0 with new beam waist

        # update observables
        o.focal[i] = fprime
        o.shift[i] = sb-sa
        o.magnif[i] = mag
        o.pos[i] = z0
        o.waist[i] = w0
        o.wonlens[i] = wa
        o.dist[i] = sa
    end
    (o.minwidth, pos) = findmin(o.wonlens)  # get minimal width and its position
    o.minwidthpos = steps[pos]            # convert it to meter
    return o
end

propagate(p::Parameters) = propagate(p.n, p.λ, p.focale, p.z0, p.w0, p.l, p.steps)

end